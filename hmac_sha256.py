
# coding: utf-8

# In[28]:




#  Program: Implement HMAC using SHA256 and verify the output with implementing standard library function
#
#           Input: message and password
#            For demonstration purpose,
#message is initialized to "First, implement SHA-256 hashing algorithm (The lecture notes describe SHA-512.  SHA-256 is very similar, but there are a few minor differences (see bottom of the page))."
#             and password is initialized to "(abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890)"
#             
#           output:Hashed value, both generated by function and from using standard library function
#  
#  Algorithm:
#  
#  SHA_256:
#  
#  To ensure that the message1 has length multiple of 512 bits:
# • first, a bit 1 is appended,
# • next, k bits 0 are appended, with k being the smallest positive integer such that l + 1 + k ≡ 448
# mod 512, where l is the length in bits of the initial message,
# • finally, the length l < 2
# 64 of the initial message is represented with exactly 64 bits, and these bits
# are added at the end of the message.
# The message shall always be padded, even if the initial length is already a multiple of 512
# 
# It uses following functions:
# sigma0(X) = Right rotation(X, 7) xor Right rotation(X, 18) xor Right shift(X, 3)
# sigma1(X) = Right rotation(X, 17) xor Right rotation(X, 19) xor Right shift(X, 10)
# Ch(X, Y,Z) = (X ^ Y ) xor (X ^ Z)
# Maj(X, Y,Z) = (X ^ Y ) xor (X ^ Z) xor (Y ^ Z)
# sum0(X) = Right rotation(X, 2) xor Right rotation(X, 13) xor Right rotation(X, 22)
# sum1(X) = Right rotation(X, 6) xor Right rotation(X, 11) xor Right rotation(X, 25)
# addition modulo 2 to the power 32 (performed by anding  4294967295)
# 
# HMAC:
# 
# To compute HMAC over the data we perform H(K XOR opad, H(K XOR ipad, text))
# 
# where K is '(abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890)'
# ipad is '00110110' *64
# opad is '01011100' *64
# H is SHA_256 function
# 
# Standard Library for verification:
# 
# It uses hmac and hashlib functions for verifying the result.

# In[4]:

#Sha-256 - Message blocking/padding
def msg_block(val):
    from math import ceil
    msglst = val
    
    msg_len = len(msglst)
    
    bin_len = '{0:064b}'.format(msg_len)
    no_of_blocks = ceil(float(msg_len/512))
    bin_len = '{0:064b}'.format(msg_len)
    msglst1 = ''
    
    if msg_len == 512:
        no_of_blocks = 2
        msglst1 = msglst1 + '1'
        for i in range(447):
            msglst1+= '0'
        msglst1+= bin_len
        msglst+= msglst1
        msglst = list(msglst)
        block = [[-1]*32]*32
        for v in range(32):  
            block[v] = msglst[v*32:v*32+32]
            
    
    else:
        n = msg_len%512
        if n<=447:
            k = 447-n
            msglst = msglst + '1'
            for i in range(k):
                msglst+= '0'
            msglst+= bin_len
            msglst = list(msglst)
            
        if n>447:
            no_of_blocks+=1
            k = 1024 - (n+1+64)
            msglst = msglst + '1'
            for i in range(k):
                msglst+= '0'
            msglst+= bin_len
            msglst = list(msglst)
            
        if n == 0:
            no_of_blocks+=1
            msglst1 = msglst1 + '1'
            for i in range(447):
                msglst1+= '0'
            msglst1+= bin_len
            msglst+= msglst1
            msglst = list(msglst)
            
        n = 16*no_of_blocks
        
        block = [[-1]*32]*n
        
        for v in range(n):  
            block[v] = msglst[v*32:v*32+32]
        
        return block
             # Right rotation and function 
def Right_Rot(p,n):
    return(p[-n:]+p[:-n]) 

            #function to convert list into integer
def strlst_to_int(q):
    s = ''
    for i in range(len(q)):
        s+= q[i]
    return(int(s, 2))

                         #Sha-256 - Message Schedule
def extend_block(block1):
    
    def Right_Shift(p,n):
        q = list(bytes(n))
        for w in range(n):
            q[w] = str(q[w])
        return q+p[:-n]
    
       #sigma0(X) = Right rotation(X, 7) xor Right rotation(X, 18) xor Right shift(X, 3)

    def sigma0(p):
        a = Right_Rot(p,7) 
        b = Right_Rot(p,18)
        c = Right_Shift(p,3)
        e = [str(ord(a) ^ ord(b)) for a,b in zip(a,b)]
        f = [str(ord(a) ^ ord(b)) for a,b in zip(e,c)]
        return(f)

    #sigma1(X) = Right rotation(X, 17) xor Right rotation(X, 19) xor Right shift(X, 10)
    
    def sigma1(p):
        a = Right_Rot(p,17) 
        b = Right_Rot(p,19)
        c = Right_Shift(p,10)
        
        e = [str(ord(a) ^ ord(b)) for a,b in zip(a,b)]
        f = [str(ord(a) ^ ord(b)) for a,b in zip(e,c)]
        return(f)
     
       #construction of remaining 48 message blocks

    
    new_block1 = [[-1]*32]*64
    
    for w in range(0,16):
        
        new_block1[w] = block1[w]
        
        
    for k in range(16,64):
    
        temp1 = strlst_to_int(sigma1(new_block1[k-2]))
        temp2 = strlst_to_int(new_block1[k-7])
        temp3 = strlst_to_int(sigma0(new_block1[k-15]))
        temp4 = strlst_to_int(new_block1[k-16])
    
        temp = temp1+temp2+temp3+temp4
        temp = temp & 4294967295
        new_block1[k] = list('{0:032b}'.format(temp))
        
    return new_block1
     

global message

    #SHA 256 implementation
        
def SHA_256(key,flag):
    
    if flag == '1':
        
        msglst = ''.join('{0:08b}'.format(x, 'b') for x in bytearray(message,'utf8'))
        
        value = key+msglst
        
    if flag == '0':
        value = key
        
    block2 = []
    block2 = msg_block(value)   

    num = int(len(block2)/16)
    
    #Ch(X, Y,Z) = (X ^ Y ) xor (X ^ Z)
        
    def ch(e,f,g):
        o= e & f
        o = list('{0:032b}'.format(o))
        e = list('{0:032b}'.format(e))
    
        for i in range(32):
            if e[i] == '0':
                e[i] = '1'
            elif e[i] == '1':
                e[i] = '0'
        e = strlst_to_int(e)
        p = e & g
        p = list('{0:032b}'.format(p))
        res = [str(ord(a) ^ ord(b)) for a,b in zip(o,p)]
        res = strlst_to_int(res)
        return res

    #Maj(X, Y,Z) = (X ^ Y ) xor (X ^ Z) xor (Y ^ Z)
    
    def major(a,b,c):
        o= a & b
        o = list('{0:032b}'.format(o))
        p = b & c
        p = list('{0:032b}'.format(p))
        q = a & c
        q = list('{0:032b}'.format(q))
        res = [str(ord(a) ^ ord(b)) for a,b in zip(o,p)]
        res = [str(ord(a) ^ ord(b)) for a,b in zip(res,q)]
        res = strlst_to_int(res)
        return res

   #sum0(X) = Right rotation(X, 2) xor Right rotation(X, 13) xor Right rotation(X, 22)
    
    def sum0(a):
        a1 = Right_Rot(a,2) 
        b1 = Right_Rot(a,13)
        c1 = Right_Rot(a,22)
        e = [str(ord(a) ^ ord(b)) for a,b in zip(a1,b1)]
        f = [str(ord(a) ^ ord(b)) for a,b in zip(e,c1)]
        res = strlst_to_int(f)
    
        return(res)

   #sum1(X) = Right rotation(X, 6) xor Right rotation(X, 11) xor Right rotation(X, 25) 

    def sum1(e):
        a1 = Right_Rot(e,6) 
        b1 = Right_Rot(e,11)
        c1 = Right_Rot(e,25)
        e1 = [str(ord(a) ^ ord(b)) for a,b in zip(a1,b1)]
        f = [str(ord(a) ^ ord(b)) for a,b in zip(e1,c1)]
        res = strlst_to_int(f)
    
        return(res)

    K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
         0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
         0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
         0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
         0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
         0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
         0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
         0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
         0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
         0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
         0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
         0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
         0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
         0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
         0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
         0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]


    H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]
    
    for n in range(num):
        new_block = []
        new_block = extend_block(block2[n*16:n*16+16])
        
        [a,b,c,d,e,f,g,h] = H
        for i in range(0,64):
            
            z = list('{0:032b}'.format(e))
            T1 = (h + sum1(z) + ch(e, f, g) + K[i] +strlst_to_int(new_block[i])) & 4294967295
            z = list('{0:032b}'.format(a))
            T2 = (sum0(z) + major(a, b, c)) & 4294967295
            h = g
            g = f
            f = e
            e = (d + T1) & 4294967295
            d = c
            c = b
            b = a
            a = (T1 + T2) & 4294967295
        if n == num-1:
            H = [hex((x+y) & 4294967295) for x,y in zip([a,b,c,d,e,f,g,h],H)]
        else:
            H = [((x+y) & 4294967295) for x,y in zip([a,b,c,d,e,f,g,h],H)]
    hash1 = ''
    for i in range(8):
        if len(H[i]) == 10:
            hash1+= H[i][2:]
        if len(H[i]) != 10:
            hash1+= "0" * (10-len(H[i])) + H[i][2:]
    
    return hash1

    
    #To compute HMAC over the data we perform H(K XOR opad, H(K XOR ipad, text))



ipad = ''
for i in range(64):
    ipad+= '00110110'
ipad = list(ipad)

opad = ''
for i in range(64):
    opad+= '01011100'
opad = list(opad)

k = '(abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890)'

key = list(''.join('{0:08b}'.format(x, 'b') for x in bytearray(k,'utf8')))

arg1 = [str(ord(a) ^ ord(b)) for a,b in zip(key,ipad)]
arg2 = [str(ord(a) ^ ord(b)) for a,b in zip(key,opad)]

key1 = ''
for n in range(0,512):
    key1+=arg1[n]
   
 
key2 = ''
for n in range(0,512):
    key2+=arg2[n]
    
message = "First, implement SHA-256 hashing algorithm (The lecture notes describe SHA-512.  SHA-256 is very similar, but there are a few minor differences (see bottom of the page)). "
print("Message to be hashed is:  ",message)
print("Password is : ",k)
v1 = SHA_256(key1,'1')

my_hexdata = v1

scale = 16 ## equals to hexadecimal

num_of_bits = 8

s = bin(int(my_hexdata, scale))[2:].zfill(num_of_bits)

s = key2+s

hmac = SHA_256(s,'0')
print('Hash value is:')
print(hmac)


  # verifying HMAC using standard library function

import hashlib
import hmac


message = bytes(message, 'utf-8')
secret = bytes(k, 'utf-8')

hash = hmac.new(secret, message, hashlib.sha256)

# to lowercase hexits
print('HMAC value using standard hmac library')
hashed = hash.hexdigest()
print(hashed)



# In[ ]:


# In[ ]:



